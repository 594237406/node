1. PHP同步阻塞，已于编写，大型网站效率低下

1. 同步/异步时间开销
    
        //同步模式
        getData('from_db');         //时间为M
        
        getData('from_remote_api'); //时间为N
        
        //异步模式
        getData('from_db', function (result) {
         //时间为M
        });
        getData('from_remote_api', function (result) {
         //时间为N
        }); 
        
        //前者为M+N，后者为max（M, N）。
    
1. 不同IO类型对应开销

    - CPU一级缓存 3
    - CPU二级缓存 14
    - 内存    250
    - 硬盘 41000000
    - 网络 240000000 

1. 资源分配
    
    如果多线程开销小于并行执行，多线程是首选的。但是创建线程与执行线程切换代价比较大。还存在锁，状态同步问题。

    添加资源，比如增加三倍服务器，是一种提升服务质量的方式，但不是唯一方式。
    
    Node在两者之间给出方案：利用单线程，远离死锁，状态同步问题。利用异步IO，让单线程远离阻塞，更好的使用CPU。
    
1. 异步IO
    
    NODE应用（JS文件运行进程）-IO调用（异步调用-操作系统-处理请求-返回数据）-其他调用-执行回调

    操作系统内核对于IO只有两种方式：阻塞/非阻塞。再调用阻塞IO时，应用程序需要等待IO完成才有返回结果。
    
    以阻塞IO，调用硬盘文件为例：系统内核读取磁盘寻道-读取数据-复制数据到内存-调用结束。
    
    阻塞IO造成CPU等待IO，浪费等待时间。为提高性能，系统内核提供非阻塞IO，非阻塞IO调用后立即返回。
    
    阻塞IO流程：NODE应用-阻塞调用（等待数据）-系统内核-读取数据（见上）-返回数据-NODE应用继续执行。
    
    非阻塞IO流程：NODE应用-非阻塞调用-系统内核-立即返回-执行回调。
    
1. 问题

    非阻塞IO性能提升是明显的，但是也存在一些问题。由于完整的IO没有完成，返回的并不是业务系统期望数据。为了获得完整数据，应用程序需要重复调用IO操作来确认是否完成，这个过程叫做轮询。
    
    阻塞IO造成CPU等待浪费，非阻塞带来的麻烦是需要轮询确认是否完全获取数据。会让CPU处于状态判断，是对CPU的资源浪费。
    
1. 我们来看看轮询技术是如何演进的

    -     read：最原始，性能最低。通过重复调用检查IO状态完成数据读取。得到最终数据前，cpu一直耗在等待上。
          流程：应用-read非阻塞调用-系统内核-立即返回-循环以上过程
    -     select:对read做改进，通过文件描述符的事件状态进行判断。采用1024数组存储状态，也就是说，最多可以同时检查1024各文件描述符。poll:对select改进，采用链表方式避免数组限制，还可以避免不必要的检查。当文件较多时，性能低下。
          流程与read类似
    -     epoll:linux下效率最高的IO事件通知机制。进入轮询时候没有检查到IO事件，将会进入休眠，直到事件将它唤醒。真正利用事件通知、执行回调方式，而不是遍历查询，所以不会浪费CPU，执行效率高。
          流程：应用-epoll调用（调用后当前进程休眠）-系统内核-返回消息-打破休眠-循环以上过程

1. 理想的异步IO

    尽管epoll已经利用事件降低cpu耗用，但是休眠期间cpu几乎闲置，对当前线程利用率不够。
    
    我们希望：应用程序发起非阻塞调用，无需遍历或者唤醒等方式轮询，可以继续处理下一个任务，只需要等待IO完成后通过信号或者回调将数据传递给应用即可。
    
    流程：应用-非阻塞调用-系统内核-立即返回-应用-其他操作-系统内核-返回数据（事件/信号）-执行回调
    
    幸运的是，linux下存在一种方式,提供了一种异步IO方式：AIO。不幸的是，只有linux下才有。
    
1. 现实中的异步IO
    
    理想比现实骨感一些。利用多线程，通过部分线程IO加轮询技术完成数据获取：让一个线程计算处理，通过线程通信将IO得到的数据进行传递，这样轻松实现了异步IO。

    流程：应用（主线程）-IO调用-IO线程1-主线程-IO调用-IO线程2
    
    IO线程1，IO线程2调用系统内核，返回数据，主线程执行回调。

    AIO就是典型的线程池模拟异步IO，但是一些缺陷很难使用。libev作者重新实现了异步IO库:libeio，也是通过采用线程池和阻塞IO模拟异步非阻塞IO。最初Node通过libeio配合libev实现IO部分，实现了异步IO。在v0.0.3中，自行实现了线程池来完成异步IO。
    
    另一种方式是windows下的IOCP，提供了理想的异步IO。内部实现原理仍然是线程池，不同之处这些线程池由系统内核管理。
    
    IOCP异步IO模型与Node异步调用模型非常相似。
    
    Node提供libuv为中间层，封装linux和windows的差异。
    
    流程：node-libuv-linux(自定义线程池)/windows(IOCP)
    
1. Node不是单线程的

    我们平时常说的node是单线程的，仅仅是在js中执行单线程罢了。无论是调用linux或者windows平台，内部完成IO任务的另有线程池。


